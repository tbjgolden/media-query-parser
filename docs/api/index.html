<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>media-query-parser api docs</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html,
      body {
        padding: 0;
        margin: 0;
      }
      body {
        padding: 18px;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
          Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      }
      code,
      .code {
        font-family: ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono",
          "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono",
          "Courier New", monospace;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css"
      integrity="sha512-hasIneQUHlh06VNBe7f6ZcHmeRTLIaQWFd43YriJ0UND19bvYRauxthDg8E4eVNPm9bRUhr5JGeqH7FRFXQu5g=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
  </head>
  <body style="text-align: center">
    <h1>API Docs</h1>
    <h2>Functions</h2>
    <pre
      style="white-space: pre-wrap"
    ><code class="language-typescript" style="display:inline-block;width:100%;max-width:106ch;text-align:left;">/**
  * creates an AST from a **media-query-list** string; parses comma-separated media queries correctly
  *
  * Important:
  *
  * - _an invalid media-query child **does not** make the media-query-list invalid_
  *  - each invalid media query child is replaced with undefined
  * - can **return** a ParserError (e.g. when there is a CSS syntax error, like an invalid string)
  *
  * @example
  * ```ts
  * console.log(parseMediaQueryList(`print, #invalid, (min-width: 1000px)`));
  * // {
  * //   n: 'query-list',
  * //   qs: [
  * //     { n: 'query', type: 'print' },
  * //     undefined,
  * //     {
  * //       n: 'query',
  * //       condition: {
  * //         n: 'condition',
  * //         op: 'and',
  * //         a: {
  * //           n: 'in-parens',
  * //           v: {
  * //             n: 'feature',
  * //             t: 'value',
  * //             f: 'min-width',
  * //             v: { n: 'dimension', v: 1000, u: 'px' }
  * //           }
  * //         }
  * //       }
  * //     }
  * //   ]
  * // }
  * ```
  */
export const parseMediaQueryList = (str: string) =&gt; QueryListNode | ParserError;
  
/**
  * creates an AST from a **media-query** string
  * @example
  * ```ts
  * console.log(parseMediaQuery(`screen and (monochrome)`));
  * // {
  * //   n: 'query',
  * //   type: 'screen',
  * //   condition: {
  * //     n: 'condition',
  * //     op: 'and',
  * //     a: {
  * //       n: 'in-parens',
  * //       v: { n: 'feature', t: 'boolean', f: 'monochrome' }
  * //     }
  * //   }
  * // }
  * ```
  */
export const parseMediaQuery = (str: string) =&gt; QueryNode | ParserError;
  
/**
  * creates an AST from a **media-condition** string
  *
  * @example
  * ```ts
  * console.log(parseMediaCondition(`((aspect-ratio &gt; 1/2) or (monochrome))`));
  * // {
  * //   n: 'condition',
  * //   op: 'and',
  * //   a: {
  * //     n: 'in-parens',
  * //     v: {
  * //       n: 'condition',
  * //       op: 'or',
  * //       a: {
  * //         n: 'in-parens',
  * //         v: {
  * //           n: 'feature',
  * //           t: 'range',
  * //           f: 'aspect-ratio',
  * //           r: {
  * //             a: { n: 'ident', v: 'aspect-ratio' },
  * //             op: '&gt;',
  * //             b: { n: 'ratio', l: 1, r: 2 }
  * //           }
  * //         }
  * //       },
  * //       bs: [
  * //         {
  * //           n: 'in-parens',
  * //           v: { n: 'feature', t: 'boolean', f: 'monochrome' }
  * //         }
  * //       ]
  * //     }
  * //   }
  * // }
  * ```
  */
export const parseMediaCondition = (str: string) =&gt; ConditionNode | ParserError;

/**
  * creates an AST from a **media-feature** string - including parentheses
  *
  * @example
  * ```ts
  * console.log(parseMediaFeature(`(min-width: 768px)`));
  * // {
  * //   n: 'feature',
  * //   t: 'value',
  * //   f: 'min-width',
  * //   v: { n: 'dimension', v: 768, u: 'px' }
  * // }
  * ```
  */
export const parseMediaFeature = (str: string) =&gt; FeatureNode | ParserError;

/**
  * turns an AST into an equivalent string
  *
  * @example
  * ```ts
  * console.log(stringify({
  *   n: 'query',
  *   type: 'screen',
  *   condition: {
  *     n: 'condition',
  *     op: 'and',
  *     a: {
  *       n: 'in-parens',
  *       v: { n: 'feature', t: 'boolean', f: 'monochrome' }
  *     }
  *   }
  * }));
  * // 'screen and (monochrome)'
  * ```
  */
export const stringify = (
  node: QueryListNode | QueryNode | ConditionNode | FeatureNode | ValueNode
) =&gt; string;
</code></pre>
    <h2>AST / Shape / Types</h2>
    <pre
      style="white-space: pre-wrap"
    ><code class="language-typescript" style="display:inline-block;width:100%;max-width:106ch;text-align:left;">export type QueryListNode = { n: "query-list"; qs: Array&lt;QueryNode | undefined&gt; };
export type QueryNode =
  | { n: "query"; prefix?: undefined; type?: undefined; condition: ConditionNode }
  | { n: "query"; prefix?: "not" | "only"; type: string; condition?: ConditionWithoutOrNode };
export type FeatureNode = BooleanFeatureNode | PlainFeatureNode | RangeFeatureNode;
export type BooleanFeatureNode = { n: "feature"; t: "boolean"; f: string };
export type PlainFeatureNode = { n: "feature"; t: "value"; f: string; v: ValueNode };
export type RangeFeatureNode = { n: "feature"; t: "range"; f: string; r: RangeNode };
export type NumberNode = { n: "number"; v: number; isInt: boolean };
export type DimensionNode = { n: "dimension"; v: number; u: string };
export type RatioNode = { n: "ratio"; l: number; r: number };
export type IdentNode = { n: "ident"; v: string };
export type NumericValueNode = NumberNode | DimensionNode | RatioNode;
export type ValueNode = NumericValueNode | IdentNode;
export type Range1Node =
  | { a: IdentNode; op: "&gt;" | "&gt;=" | "&lt;" | "&lt;=" | "="; b: NumericValueNode }
  | { a: NumericValueNode; op: "&gt;" | "&gt;=" | "&lt;" | "&lt;=" | "="; b: IdentNode };
export type Range2Node =
  | { a: NumericValueNode; op: "&lt;" | "&lt;="; b: IdentNode; op2: "&lt;" | "&lt;="; c: NumericValueNode }
  | { a: NumericValueNode; op: "&gt;" | "&gt;="; b: IdentNode; op2: "&gt;" | "&gt;="; c: NumericValueNode };
export type RangeNode = Range1Node | Range2Node;
export type NotConditionNode = { n: "condition"; op: "not"; a: InParensNode; bs?: undefined };
export type AndConditionNode = { n: "condition"; op: "and"; a: InParensNode; bs?: InParensNode[] };
export type OrConditionNode = { n: "condition"; op: "or"; a: InParensNode; bs?: InParensNode[] };
export type ConditionNode = NotConditionNode | AndConditionNode | OrConditionNode;
export type ConditionWithoutOrNode = NotConditionNode | AndConditionNode;
export type GeneralEnclosedNode = { n: "general-enclosed" };
export type InParensNode = { n: "in-parens"; v: ConditionNode | FeatureNode | GeneralEnclosedNode };</code></pre>
    <h2>ParserError</h2>
    <pre
      style="white-space: pre-wrap"
    ><code class="language-typescript" style="display:inline-block;width:100%;max-width:106ch;text-align:left;">export type ParserError = { errid: ParserErrId; start: number; end: number; child?: ParserError };
export type ParserErrId =
  | "EXPECT_LPAREN_OR_TYPE"
  | "EXPECT_TYPE"
  | "EXPECT_CONDITION"
  | "EXPECT_AND"
  | "EXPECT_LPAREN_OR_TYPE_OR_MODIFIER"
  | "EXPECT_LPAREN"
  | "EXPECT_FEATURE_OR_CONDITION"
  | "EXPECT_AND_OR_OR"
  | "EXPECT_RPAREN"
  | "EXPECT_VALUE"
  | "EXPECT_RANGE"
  | "MIX_AND_WITH_OR"
  | "MISMATCH_PARENS"
  | "EMPTY_QUERY"
  | "EMPTY_CONDITION"
  | "EMPTY_FEATURE"
  | "NO_LCURLY"
  | "NO_SEMICOLON"
  | "INVALID_FEATURE"
  | "INVALID_RANGE"
  | "INVALID_STRING";

/**
* a type guard that asserts whether `value` is of type ParserError
*
* tolerant of any input type, you can assume it will be true if (and only if) it is a ParserError
*/
export const isParserError = (value: unknown) =&gt; value is ParserError;
</code></pre>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"
      integrity="sha512-rdhY3cbXURo13l/WU9VlaRyaIYeJ/KBakckXIvJNAQde8DgpOmE+eZf7ha4vdqVjTtwQt69bD2wH2LXob/LB7Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>
